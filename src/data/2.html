<html>
<head>
<title>Binary Counters, Delay, Telephone Ring Gen, Meter</title>
</head>
<body bgcolor="#ffffff">
<blockquote>
<a name="counter.gif"></a>
<center><h3>1 Second Time Base From Crystal Oscillator </h3></center>
<br>

The schematic below illustrates dividing a crystal oscillator signal
by the crystal frequency to obtain an accurate (0.01%) 1 second time base.
Two cascaded 12 stage counters (CD4040) form a 24 stage binary counter and
the appropriate bits are gated together to produce the desired division.
Using a crystal of some even multiple of 2 is desirable so that one stage
of the counter automatically toggles every second which eliminates the need
for the NAND gate and reset circuitry, however the circuit below illustrates
using a crystal which is not an even multiple of 2 and so requires
additional components.

<p>
Using a 50 Khz crystal, a count of 50000 is detected when the appropriate
counter bits that add up to 50000 are all high. This corresponds to
bits 15 (32768) + 14 (16384) + 9 (512) + 8 (256) + 6 (64) + 4 (16).
Bits 14 and 15 are the 3rd and 4th stages of the second counter, bit 0
is the first stage of the first counter (Q1, pin 9). To use a 100 Khz
crystal, each bit would be moved one to the right so the total would be
(65536 + 32768 + 1024 + 512 + 128 + 32 = 100,000).
Using a 1 Mhz crystal, the following bits would be needed:
<pre>
Bit 19 - Right counter - Q8 - pin 13  -  Decimal value = 524288
    18                    7        4                     262144
    17                    6        2                     131072
    16                    5        3                      65536
    14                    3        6                      16384
     9 - Left counter  - 10       14                        512
     6                    7        4                         64
                                                       ---------
                                                       1,000,000
</pre>
At 1 Mhz, the 330K resistor in the oscillator circuit will need to be
reduced proportionally to about 15K.

When the terminal count is reached, a 7 uS reset pulse is generated by
the Schmitt Trigger inverter stage that follows the NAND gate. The 47K
resistor and 470 picofarad capacitor sustain the output so that the
counters are reliably reset to zero. This is less than one clock cycle
at 50Khz and does not introduce an error but would amount to 7 cycles at
1 MHz which would cause the counters to lose 7 microseconds of time
per second. It's not much of an error (7 parts in a million)
but it would be there. The minimum reset pulse width for the 4040 CMOS
counters is about 1.5 uS, so the reset pulse cannot be made much shorter.

<br>
<br><img  src="counter.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr  size=1>

<a name="oscilate.gif"></a>
<center><h3>32.768 KHz oscillator using a watch crystal </h3></center>
<br>
Below are a couple circuits you can use to produce a 32.768 KHz square wave
from a common watch crystal. The output can be fed to a 15 stage binary
counter to obtain a 1 second square wave. The circuit on the left using
the 4069 inverter is recommended over the transistor circuit and produces a
better waveform. The single transistor circuit produces more of a ramping
waveform but the output swings the full supply voltage range so it will
easily drive the input to a CMOS binary counter.

<br>
<br><img  src="oscilate.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr  size=1>

<a name="counter1.gif"></a>
<center><h3>Generating Long Time Delays</h3></center>
<br>

Generating long delays of several hours can be accomplished by
using a low frequency oscillator and a binary counter as shown below.
A single Schmitt Trigger inverter stage (1/6 of 74HC14) is used
as a squarewave oscillator to produce a low frequency of about 0.5
Hertz. The 10K resistor in series with the input (pin 1) reduces
the capacitor discharge current through the inverter input internal
protection diodes if the circuit is suddenly disconnected from the supply.
This resistor may not be needed but is a good idea to use.
<p>
The frequency is divided by two at each successive stage
of the 12 stage binary counter (CD4040) which yields about 1 hour
of time before the final stage (Q12) switches to a high state.
Longer or shorter times can be obtained by adjusting the oscillator
frequency or using different RC values. Each successive stage changes state
when the preceding stage switches to a low state (0 volts), thus the
frequency at each stage is one half the frequency of the stage before.
Waveform diagrams are shown for the last 3 stages. To begin the delay
cycle, the counter can be reset to zero by momentarily connecting the
reset line (pin 11) to the positive supply. Timing accuracy will not be
as good as with a crystal oscillator and may only be around 1 or
2% depending on the stability of the oscillator capacitor.

<br>
<br><img  src="counter1.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>

<a name="ring2.gif"></a>
<center><H3>Telephone Ring Generator Using Switching Supply</H3></center>

The telephone ring generator shown below generates the needed high voltage
from a simple switching mode power supply (SMPS) which employs a CMOS
Schmitt Trigger square wave oscillator, 10 mH inductor, high voltage
switching transistor (TIP47 or other high voltage, 1 amp transistor) and
a driver transistor (2N3053). The inductor should have a low DC resistance
of 1.5 ohms or less. The switching supply must have a load connected
to prevent the voltage from rising too high, so a 22K resistor is used across
the output which limits the voltage to about 120 DC with the phone ringer
disconnected and about 90 volts DC connected. The output voltage can be
adjusted by changing the value of the 150K resistor between pins 10 and 11
which will alter the oscillator frequency (frequency is around 800 Hz as
shown). The supply is gated on and off
by a second Schmitt Trigger oscillator (pins 12/13) so that the phone rings
for about 2 seconds and then the circuit idles for about a minute between rings.
These times can be adjusted with the 10K and 300K resistors connected to pin
12. The push button shown is used to manually ring the phone.
The 25Hz ringing frequency is generated by another Schmitt Trigger
oscillator (pins 1/2) which controls the H bridge transistor output circuit.
The 6 transistors in the output stage (4 NPN, 2 PNP) should be high voltage
types rated at 200 volts collector to emitter or more. The ringer will only
draw around 10 mA, so the output transistors can have a low current rating but
must have a high voltage rating. I used TIP47s and small signal PNPs
of unknown numbers that I had on hand, but other types such as NTE287 (NPN)
and NTE288 (PNP) should work. Both have a 300 volt C-E rating and cost about
$0.95 from mail order houses.

<p>

The two 470 ohm resistors connected to the
output serve to limit the current in case the output is shorted. I never
tried shorting the output to see how effective the resistors are, but I did
lose a couple transistors and then decided to add the resistors. They should
limit the surge to around 120 mA which should be low enough to prevent damage.
The circuit draws around 250 mA when the ring signal is present so if you
want to operate it from batteries, six 'D' type alkaline cells are recommended.
It probably won't work with a small 9 volt battery.

<p><img  src="ring2.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>


<a name="ring1.gif"></a>
<center><H3>Telephone Ring Generator Using Small Power Transformer</H3></center>
This ring generator will ring a telephone once every 10 seconds. The
interval between rings can be lengthened or shortened by varying the
value of the 1 Meg resistor. The 70 volt/ 30 Hz ring voltage is produced
from the 120 volt side of a small 12.6 VAC power transformer (Radio
Shack 273-1365). Both capacitors connected across the transformer
windings are non-polarized / 100 volts. Circuit draws about 300mA from
the 12 volt DC power supply during the ringing interval.
<p>
<IMG src="ring1.gif">
<center><a href="index.html#menu">Menu</a></center>
<HR>

<a name="meter.gif"></a>
<center><h3>LED 12 Volt Lead Acid Battery Meter</h3></center>
<br>

In the circuit below, a quad voltage comparator (LM339) is used
as a simple bar graph meter to indicate the charge condition of a
12 volt, lead acid battery. A 5 volt reference voltage is connected
to each of the (+) inputs of the four comparators and the (-)
inputs are connected to successive points along a voltage divider.
The LEDs will illuminate when the voltage at the negative (-) input
exceeds the reference voltage. Calibration can be done by adjusting
the 2K potentiometer so that all four LEDs illuminate when the battery
voltage is 12.7 volts, indicating full charge with no load on the battery.
At 11.7 volts, the LEDs should be off indicating a dead battery.
Each LED represents an approximate 25% change in charge condition
or 300 millivolts, so that 3 LEDs indicate 75%, 2 LEDs indicate 50%, etc.
The actual voltages will depend on temperature conditions and battery type,
wet cell, gel cell etc. Additional information on battery maintenance
can be found at: <br>
<a href="http://www.batterystuff.com/battery/battery_tutorial.htm#Battery Maintenance">
Battery Maintenance Tutorial</a>


<br>
<br><img  src="meter.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>

<a name="tl431.gif"></a>
<center><h3>3.6 Volt cell phone battery meter</h3></center>
<br>

 This is a similar circuit to the above and provides a 4 LED
 bar graph indicating the voltage of a common 3.6 volt
 Lithium - Ion recharable cell phone battery. The reference
 voltage is provided by a TL431 programmable voltage source
 which is set to 3.9 volts where the TL431 connects to the
 1K resistor. The lower reference for the LED at pin 14 is
 set with the 5K adjustable resistor.
<p>
 The programmed voltage of the TL431 is worked out with a
 voltage divider (10K 5.6K). The adjustment terminal or
 junction of the two resistors is always 2.5 volts. So, if
 we use a 10K resistor from the adjustment terminal to ground,
 the resistor current will be 2.5/10000 = 250uA. This same current
 flows through the upper resistor (5.6K) and produces a voltage
 drop of .00025 * 5600 = 1.4 volts. So the shunt regulated output
 voltage at the cathode of the TL431 will be 2.5 + 1.4, or 3.9 volts.
 <p>
 Working out the LED voltages, there are three 390 ohm resistors
 in series with another adjustable (5K) resistor at the bottom.
 Assuming the bottom resistor is set to 2K ohms, the total
 resistance is 390+390+390+2000 = 3170 ohms. So, the resistor
 current is the reference voltage (3.9) divided by the total resistance,
 or about 3.9/ (390 + 390 + 390 + 2000) equals 1.23 mA. This gives us
 about .00123*2000= 2.46 volts for the bottom LED, and about
 .00123*390 = .48 volts for each step above the bottom. So, the LEDs
 should light at steps of 2.46, 2.94, 3.42, and 3.9. A fully charged
 cell phone battery is about 4.2 volts. You can adjust the 5.6K resistor
 to set the top voltage higher or lower, and adjust the lower 5K resistor
 to set the bottom LED for the lowest voltage. But you do need a 6 to
 12 volt or greater battery to power the circuit.

<p>
<br><img  src="tl431.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>


<a name="vumeter.gif"></a>
<center><h3>LED VU Meter</h3></center>
<br>

The circuit below uses two quad voltage comparators (LM339) to illuminate
a series of 8 LEDs indicating volume level. Each of the 8 comparators is
biased at increasing voltages set by the voltage divider so that
the lower right LED comes on first when the input is about 400 millivolts
or about 22 milliwatts peak in an 8 ohm system. The divider voltages are
set so that each LED represents about twice the power level as the one before
so the scale extends from 22 milliwatts to about 2.5 watts when all LEDs
are lit. The sensitivity can be decreased with the input control to read
higher levels. I have not built or tested this circuit, so please let
me know if you have problems getting it working. The power levels
should be as follows:
<ul>
<li>1 LED =  22mW
<li>2 LEDs = 42mW
<li>3 LEDs = 90mW
<li>4 LEDs = 175mW
<li>5 LEDs = 320mW
<li>6 LEDs = 650mW
<li>7 LEDs = 1.2 Watts
<li>8 LEDs = 2.5 watts
</ul>

<br>
<br><img  src="ledmeter.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>

<a name="1mameter.gif"></a>
<center><h3>Analog Milliamp Meter Used as Voltmeter</h3></center>
<br>

A milliamp meter can be used as a volt meter by adding a series resistance.
The resistance needed is the full scale voltage reading divided by the
full scale current of the meter movement. So, if you have a 1 milliamp
meter and you want to read 0-10 volts you will need a total resistance of
10/.001 = 10K ohms. The meter movement itself will have a small resistance
which will be part of the total 10K resistance, but it is usually low enough
to ignore. The meter in the example below has a resistance of 86 ohms so
the true resistor value needed would be 10K-86 or 9914 ohms. But using a
10K standard value will be within 1% so we can ignore the 86 ohms. For
a full scale reading of 1 volt, the meter resistnace would be more significant
since it would be about 8% of the total 1K needed, so you would probably
want to use a 914 ohm resistor, or 910 standard value.

The milliamp meter can also be used to measure higher currents by adding
a parallel resistance. The meter resistance now becomes very significant
since to increase the range by a factor of ten, we need to bypass 9/10
of the total current with the parallel resistor. So, to convert the
1 milliamp meter to a 10 milliamp meter, we will need a parallel resistor
of 86/9 = 9.56 ohms.

<br>
<br><img  src="1mameter.gif">
<center><a href="index.html#menu">Menu</a></center>
<hr>
</blockquote>
<!-- WiredMinds eMetrics tracking with Enterprise Edition V5.4 START -->
<script type='text/javascript' src='https://count.carrierzone.com/app/count_server/count.js'></script>
<script type='text/javascript'><!--
wm_custnum='4b5dc18b1765aace';
wm_page_name='page11.htm';
wm_group_name='/services/webpages/b/o/bowdenshobbycircuits.info/public';
wm_campaign_key='campaign_id';
wm_track_alt='';
wiredminds.count();
// -->
</script>
<!-- WiredMinds eMetrics tracking with Enterprise Edition V5.4 END -->
</BODY>
</HTML>
